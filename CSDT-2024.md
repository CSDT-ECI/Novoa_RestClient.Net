# Refactoring + Code Smells
## Code Smells
- Se detectó uso Excesivo de desactivación de advertencias relacionadas con diferentes code smells
	- Las categorias mas desactivadas son:
		- **Nombramiento de variables**: Se relacionan con la nomenclatura de las variables.
		- **Inicialización de variables**: Se relacionan con la no inicialización de las variables no nulas.
		- **Correcto uso de los tipos de datos**: Se relacionan con el uso correcto de los tipos.
- Se detectó caso omiso deliveradamente a las advertencias del IDE, incluso cuando estas estan marcadas como errores.
- Se detectó una clase Dios, la cual tiene una cantidad excesiva de métodos y atributos, alrededor de 350 lineas de código para la clase principal.
- Falta de buenas prácticas.
- Insuficiente documentación y comentarios en el código.
- Pruebas unitarias existentes no son detectadas.
- Desorganización en el proyecto de pruebas.
- Se detectó TODOs sin resolver.
- Hay poco uso de carpetas para organizar y agrupar el código.
- Hay mucho codigo dedicado a suprimir advertencias del IDE.
- Los namespaces no corresponden a la estructura de carpetas y la advertencia se suprime.
- La arquitectura Modelo Vista Controlador solo se aplica en ciertas partes del proyecto.
- Esta joya: 
		- //Note: not sure why this is necessary...
		- RestClient.Net/DefaultGetHttpRequestMessage.cs Linea 69.
		- Clase llamada "Stuff.cs" con ningún comentario que la explique.
		- //Is this good?
		- RestClient.Net.Abstractions/CallExtensions.cs Linea 66

## Tecnicas de Refactoring Recomendadas
- **Renombrar variables**: Se recomienda cambiar el nombre de las variables para que sean más descriptivas.
- **Extraer métodos**: Se recomienda extraer métodos para que cada método haga una sola cosa.
- **Eliminar código muerto**: Se recomienda eliminar código que no se utiliza.
- **Eliminar comentarios innecesarios**: Se recomienda eliminar comentarios que no aportan información.
- **Solo implementar codigo que se necesita**: Si no se entiende que hace algo, es mejor no implementarlo.
- **Sustituir Valores por Referencias**: Se recomienda cambiar los valores primitivos por referencias cuando sea posible.
- **Cambiar la arquitectura del Proyecto**: Se recomienda refactorizar y cambiar la arquitectura del proyecto para que sea más fácil de entender y mas escalable.
- **Adaptar el proyecto para que sea Open Source Friendly**: Si se va a dejar de desarrollar el proyecto, se recomienda adaptar el proyecto para que sea más fácil de entender y mantener por otros desarrolladores anonimos.
- **Adaptar los pipelines**: Los pipelines de Github Actions se pueden mejorar para que analicen mas aspectos del código y despues de creados no deben ser ignorados.

## Caracteristicas de Clean Code que se cumplen y no se cumple
- **KISS (Keep It Simple, Stupid)**: No se cumple, el código es muy complejo y no esta diseñado para ser intrpretado por alguien que no es el desarrollador original. Ademas faltan carpetas para organizar el código.
- **DRY (Don't Repeat Yourself)**: Nada es aparentemente repetitivo, pero hay mucho código que no se necesita.
- **YAGNI (You Aren't Gonna Need It)**: Se cumple, no hay funciones aparentes que no se necesiten y la herramienta cumple con los requerimientos funcionales.
- **SOLID**: El principio de responsabilidad unica no se cumple. Existe una clase dios que tiene demasiadas responsabilidades y las entidades y se puede partir en varias clases complementarias. Ademas no existe la segregacion de interfaces porque casi que no se usan, lo cual genera una acoplación entre los componentes.

## Pracicas de Extreme Programming que podrian ayudar para mejorar la calidad del código
- **Pair Programming**: Se nota que este es un proyecto desarrollado por una sola persona, el Pair Programming podría haber ayudado a detectar errores y mejorar la calidad del código.
- **Refactorización**: Este proyecto comenzó con una arquitectura sencilla pero al agregar más funcionalidades se quedó corto, la refactorización podría haber ayudado a mejorar la calidad del código cuando se agregaron nuevas funcionalidades.
- **Metafora**: Este proyecto tiene falta de comunicación y documentación, la metáfora podría haber ayudado a que todos los miembros del equipo entiendan el proyecto y se comuniquen mejor.
 - **Presentacion del codigo**: Presentar el codigo a otros desarrolladores para que den su opinion y detecten errores, no solo la funcionalidad.
- **Standar de Pruebas**: Las pruebas unitarias no solo no se detectan, sino que la carpeta que las contiene esta desorganizada, un estándar de pruebas podría haber ayudado a detectar errores y mejorar la calidad y legibilidad del código.
- **Aceptar el cambio**: El proyecto no se adapta a los cambios, se siguen ignorando las advertencias del IDE y no se adaptan los pipelines de Github Actions para analizar más aspectos del código. Ademas esta atorado en una versión de .NET Core que ya no recibe soporte lo cual lo hace mucho mas complejo innecesariamente.

## Deuda técnica en procesos. Implementación de Integración continua
- El proyecto original cuenta con un solo workflow que se dedica a correr las pruebas unitarias en los frameworks netcore3.1, .Net 5, .Net 6 y .Net7.
- No se cuenta con compatibilidad con otras versiones de .NET como la 8.0 que es la ultima versión estable ni la 9.0 que esta en desarrollo.
- Al intentar copiar el workflow en el nuevo proyecto, se detecta que el pipeline no funciona pues sus dependencias estan seriamente desactualizadas. Se intentara volver a correr pero solo en la ultima version de .Net 7. Incluso en este caso, parte de la logica del programa es la genereación de documentación, pero esta está generando errores de compilación.
- Despues de añadir la anotación `<GenerateDocumentationFile>true</GenerateDocumentationFile>` en el archivo .csproj de varios ed los proyectos de la solución, se logra que el pipeline compile correctamente y que las pruebas unitarias corran. Pero 171 que existen, 2 fallan.
- Se instaló una herramienta de analisis de codigo en el pipeline llamada SuperLint que analizará todo el nuevo codigo que se suba al repositorio. 
- El proyecto original cuenta con Dependabot instalado, pero es ignorado. Todas las dependencias desactualizadas se estan dejando sin actualizar bajo desicion del desarrollador. Esto es especialmente malo porque se sabe que la version de Newtonsoft.Json que se esta usando tiene vulnerabilidades criticas conocidas.
- Se activó Dependabot en la nueva version para que actualice las dependencias del proyecto, y a diferencia del original, esta vez no se van a ignorar sus advertencias.
- Se instaló un Github Action llamado Typos Master que ayuda a encontrar errores ortograficos en el codigo. Por ahora solo esta activado en el archivo .github/workflows/buildandtest.yml pues el repositorio original si tenia errores ortograficos en este archivo.
- El proyecto no cuenta con un pipeline de integración continua que valide la calidad del código, solo se corren las pruebas unitarias.# Refactoring + Code Smells
## Code Smells
- Se detectó uso Excesivo de desactivación de advertencias relacionadas con diferentes code smells
- Las categorias mas desactivadas son:
	- **Nombramiento de variables**: Se relacionan con la nomenclatura de las variables.
	- **Inicialización de variables**: Se relacionan con la no inicialización de las variables no nulas.
	- **Correcto uso de los tipos de datos**: Se relacionan con el uso correcto de los tipos.
- Se detectó caso omiso deliveradamente a las advertencias del IDE, incluso cuando estas estan marcadas como errores.
- Se detectó una clase Dios, la cual tiene una cantidad excesiva de métodos y atributos, alrededor de 350 lineas de código para la clase principal.
- Falta de buenas prácticas.
- Insuficiente documentación y comentarios en el código.
- Pruebas unitarias existentes no son detectadas.
- Desorganización en el proyecto de pruebas.
- Se detectó TODOs sin resolver.
- Hay poco uso de carpetas para organizar y agrupar el código.
- Hay mucho codigo dedicado a suprimir advertencias del IDE.
- Los namespaces no corresponden a la estructura de carpetas y la advertencia se suprime.
- La arquitectura Modelo Vista Controlador solo se aplica en ciertas partes del proyecto.
- Esta joya: 
		- //Note: not sure why this is necessary...
		- RestClient.Net/DefaultGetHttpRequestMessage.cs Linea 69.
- Clase llamada "Stuff.cs" con ningún comentario que la explique.
- Lineas de comentario como:  //Is this good?
		- RestClient.Net.Abstractions/CallExtensions.cs Linea 66

## Tecnicas de Refactoring Recomendadas
- **Renombrar variables**: Se recomienda cambiar el nombre de las variables para que sean más descriptivas.
- **Extraer métodos**: Se recomienda extraer métodos para que cada método haga una sola cosa.
- **Eliminar código muerto**: Se recomienda eliminar código que no se utiliza.
- **Eliminar comentarios innecesarios**: Se recomienda eliminar comentarios que no aportan información.
- **Solo implementar codigo que se necesita**: Si no se entiende que hace algo, es mejor no implementarlo.
- **Sustituir Valores por Referencias**: Se recomienda cambiar los valores primitivos por referencias cuando sea posible.
- **Cambiar la arquitectura del Proyecto**: Se recomienda refactorizar y cambiar la arquitectura del proyecto para que sea más fácil de entender y mas escalable.
- **Adaptar el proyecto para que sea Open Source Friendly**: Si se va a dejar de desarrollar el proyecto, se recomienda adaptar el proyecto para que sea más fácil de entender y mantener por otros desarrolladores anonimos.
- **Adaptar los pipelines**: Los pipelines de Github Actions se pueden mejorar para que analicen mas aspectos del código y despues de creados no deben ser ignorados.

## Caracteristicas de Clean Code que se cumplen y no se cumple
- **KISS (Keep It Simple, Stupid)**: No se cumple, el código es muy complejo y no esta diseñado para ser intrpretado por alguien que no es el desarrollador original. Ademas faltan carpetas para organizar el código.
- **DRY (Don't Repeat Yourself)**: Nada es aparentemente repetitivo, pero hay mucho código que no se necesita.
- **YAGNI (You Aren't Gonna Need It)**: Se cumple, no hay funciones aparentes que no se necesiten y la herramienta cumple con los requerimientos funcionales.
- **SOLID**: El principio de responsabilidad unica no se cumple. Existe una clase dios que tiene demasiadas responsabilidades y las entidades y se puede partir en varias clases complementarias. Ademas no existe la segregacion de interfaces porque casi que no se usan, lo cual genera una acoplación entre los componentes.

## Pracicas de Extreme Programming que podrian ayudar para mejorar la calidad del código
- **Pair Programming**: Se nota que este es un proyecto desarrollado por una sola persona, el Pair Programming podría haber ayudado a detectar errores y mejorar la calidad del código.
- **Refactorización**: Este proyecto comenzó con una arquitectura sencilla pero al agregar más funcionalidades se quedó corto, la refactorización podría haber ayudado a mejorar la calidad del código cuando se agregaron nuevas funcionalidades.
- **Metafora**: Este proyecto tiene falta de comunicación y documentación, la metáfora podría haber ayudado a que todos los miembros del equipo entiendan el proyecto y se comuniquen mejor.
- **Presentacion del codigo**: Presentar el codigo a otros desarrolladores para que den su opinion y detecten errores, no solo la funcionalidad.
- **Standar de Pruebas**: Las pruebas unitarias no solo no se detectan, sino que la carpeta que las contiene esta desorganizada, un estándar de pruebas podría haber ayudado a detectar errores y mejorar la calidad y legibilidad del código.
- **Aceptar el cambio**: El proyecto no se adapta a los cambios, se siguen ignorando las advertencias del IDE y no se adaptan los pipelines de Github Actions para analizar más aspectos del código. Ademas esta atorado en una versión de .NET Core que ya no recibe soporte lo cual lo hace mucho mas complejo innecesariamente.

## Deuda técnica en procesos. Implementación de Integración continua
- El proyecto original cuenta con un solo workflow que se dedica a correr las pruebas unitarias en los frameworks netcore3.1, .Net 5, .Net 6 y .Net7.
- El proyecto no cuenta con un pipeline de integración continua que valide la calidad del código, solo se corren las pruebas unitarias.
- No se cuenta con compatibilidad con otras versiones de .NET como la 8.0 que es la ultima versión estable ni la 9.0 que esta en desarrollo.
- Al intentar copiar el workflow en el nuevo proyecto, se detecta que el pipeline no funciona pues sus dependencias estan seriamente desactualizadas. Se intentara volver a correr pero solo en la ultima version de .Net 7. Incluso en este caso, parte de la logica del programa es la genereación de documentación, pero esta está generando errores de compilación.
 - Despues de añadir la anotación `<GenerateDocumentationFile>true</GenerateDocumentationFile>` en el archivo .csproj de varios de los proyectos de la solución, se logra que el pipeline compile correctamente y que las pruebas unitarias corran. Pero 171 que existen, 2 fallan.
- Se instaló una herramienta de analisis de codigo en el pipeline llamada SuperLint que analizará todo el nuevo codigo que se suba al repositorio. 
- El proyecto original cuenta con Dependabot instalado, pero es ignorado. Todas las dependencias desactualizadas se estan dejando sin actualizar bajo desicion del desarrollador. Esto es especialmente malo porque se sabe que la version de Newtonsoft.Json que se esta usando tiene vulnerabilidades criticas conocidas.
- Se activó Dependabot en la nueva version para que actualice las dependencias del proyecto, y a diferencia del original, esta vez no se van a ignorar sus advertencias.
- Se instaló un Github Action llamado Typos Master que ayuda a encontrar errores ortograficos en el codigo. Por ahora solo esta activado en el archivo .github/workflows/buildandtest.yml pues el repositorio original si tenia errores ortograficos en este archivo.